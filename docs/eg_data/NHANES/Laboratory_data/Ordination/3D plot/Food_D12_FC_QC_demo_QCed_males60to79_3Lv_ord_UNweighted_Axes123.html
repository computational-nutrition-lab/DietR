<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<style>body{background-color:white;}</style>
<script src="libs/htmlwidgets-1.6.2/htmlwidgets.js"></script>
<script src="libs/rglWebGL-binding-1.0.1/rglWebGL.js"></script>
<link href="libs/rglwidgetClass-1.0.1/rgl.css" rel="stylesheet" />
<script src="libs/rglwidgetClass-1.0.1/rglClass.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/utils.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/buffer.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/subscenes.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/shaders.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/textures.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/projection.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/mouse.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/init.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/pieces.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/draw.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/controls.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/selection.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/rglTimer.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/pretty.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/axes.src.js"></script>
<script src="libs/rglwidgetClass-1.0.1/animation.src.js"></script>
<!--html_preserve--><script type = "text/plain" id = "rgl-vertex-shader">
#line 2 1
// File 1 is the vertex shader
#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#endif

attribute vec3 aPos;
attribute vec4 aCol;
uniform mat4 mvMatrix;
uniform mat4 prMatrix;
varying vec4 vCol;
varying vec4 vPosition;

#ifdef NEEDS_VNORMAL
attribute vec3 aNorm;
uniform mat4 normMatrix;
varying vec4 vNormal;
#endif

#if defined(HAS_TEXTURE) || defined (IS_TEXT)
attribute vec2 aTexcoord;
varying vec2 vTexcoord;
#endif

#ifdef FIXED_SIZE
uniform vec3 textScale;
#endif

#ifdef FIXED_QUADS
attribute vec3 aOfs;
#endif

#ifdef IS_TWOSIDED
#ifdef HAS_NORMALS
varying float normz;
uniform mat4 invPrMatrix;
#else
attribute vec3 aPos1;
attribute vec3 aPos2;
varying float normz;
#endif
#endif // IS_TWOSIDED

#ifdef FAT_LINES
attribute vec3 aNext;
attribute vec2 aPoint;
varying vec2 vPoint;
varying float vLength;
uniform float uAspect;
uniform float uLwd;
#endif


void main(void) {
  
#ifndef IS_BRUSH
#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG)
  vPosition = mvMatrix * vec4(aPos, 1.);
#endif
  
#ifndef FIXED_QUADS
  gl_Position = prMatrix * vPosition;
#endif
#endif // !IS_BRUSH
  
#ifdef IS_POINTS
  gl_PointSize = POINTSIZE;
#endif
  
  vCol = aCol;
  
#ifdef NEEDS_VNORMAL
  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));
#endif
  
#ifdef IS_TWOSIDED
#ifdef HAS_NORMALS
  /* normz should be calculated *after* projection */
  normz = (invPrMatrix*vNormal).z;
#else
  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));
  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;
  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));
  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;
  normz = pos1.x*pos2.y - pos1.y*pos2.x;
#endif
#endif // IS_TWOSIDED
  
#ifdef NEEDS_VNORMAL
  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);
#endif
  
#if defined(HAS_TEXTURE) || defined(IS_TEXT)
  vTexcoord = aTexcoord;
#endif
  
#if defined(FIXED_SIZE) && !defined(ROTATING)
  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);
  pos = pos/pos.w;
  gl_Position = pos + vec4(aOfs*textScale, 0.);
#endif
  
#if defined(IS_SPRITES) && !defined(FIXED_SIZE)
  vec4 pos = mvMatrix * vec4(aPos, 1.);
  pos = pos/pos.w + vec4(aOfs,  0.);
  gl_Position = prMatrix*pos;
#endif
  
#ifdef FAT_LINES
  /* This code was inspired by Matt Deslauriers' code in 
   https://mattdesl.svbtle.com/drawing-lines-is-hard */
  vec2 aspectVec = vec2(uAspect, 1.0);
  mat4 projViewModel = prMatrix * mvMatrix;
  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);
  currentProjected = currentProjected/currentProjected.w;
  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);
  vec2 currentScreen = currentProjected.xy * aspectVec;
  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;
  float len = uLwd;
  vec2 dir = vec2(1.0, 0.0);
  vPoint = aPoint;
  vLength = length(nextScreen - currentScreen)/2.0;
  vLength = vLength/(vLength + len);
  if (vLength > 0.0) {
    dir = normalize(nextScreen - currentScreen);
  }
  vec2 normal = vec2(-dir.y, dir.x);
  dir.x /= uAspect;
  normal.x /= uAspect;
  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);
  gl_Position = currentProjected + offset;
#endif
  
#ifdef IS_BRUSH
  gl_Position = vec4(aPos, 1.);
#endif
}
</script>
<script type = "text/plain" id = "rgl-fragment-shader">
#line 2 2
// File 2 is the fragment shader
#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#endif
varying vec4 vCol; // carries alpha
varying vec4 vPosition;
#if defined(HAS_TEXTURE) || defined (IS_TEXT)
varying vec2 vTexcoord;
uniform sampler2D uSampler;
#endif

#ifdef HAS_FOG
uniform int uFogMode;
uniform vec3 uFogColor;
uniform vec4 uFogParms;
#endif

#if defined(IS_LIT) && !defined(FIXED_QUADS)
varying vec4 vNormal;
#endif

#if NCLIPPLANES > 0
uniform vec4 vClipplane[NCLIPPLANES];
#endif

#if NLIGHTS > 0
uniform mat4 mvMatrix;
#endif

#ifdef IS_LIT
uniform vec3 emission;
uniform float shininess;
#if NLIGHTS > 0
uniform vec3 ambient[NLIGHTS];
uniform vec3 specular[NLIGHTS]; // light*material
uniform vec3 diffuse[NLIGHTS];
uniform vec3 lightDir[NLIGHTS];
uniform bool viewpoint[NLIGHTS];
uniform bool finite[NLIGHTS];
#endif
#endif // IS_LIT

#ifdef IS_TWOSIDED
uniform bool front;
varying float normz;
#endif

#ifdef FAT_LINES
varying vec2 vPoint;
varying float vLength;
#endif

void main(void) {
  vec4 fragColor;
#ifdef FAT_LINES
  vec2 point = vPoint;
  bool neg = point.y < 0.0;
  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :
                 -(point.y - vLength)/(1.0 - vLength);
#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)
  if (neg && length(point) <= 1.0) discard;
#endif
  point.y = min(point.y, 0.0);
  if (length(point) > 1.0) discard;
#endif // FAT_LINES
  
#ifdef ROUND_POINTS
  vec2 coord = gl_PointCoord - vec2(0.5);
  if (length(coord) > 0.5) discard;
#endif
  
#if NCLIPPLANES > 0
  for (int i = 0; i < NCLIPPLANES; i++)
    if (dot(vPosition, vClipplane[i]) < 0.0) discard;
#endif
    
#ifdef FIXED_QUADS
    vec3 n = vec3(0., 0., 1.);
#elif defined(IS_LIT)
    vec3 n = normalize(vNormal.xyz);
#endif
    
#ifdef IS_TWOSIDED
    if ((normz <= 0.) != front) discard;
#endif
    
#ifdef IS_LIT
    vec3 eye = normalize(-vPosition.xyz/vPosition.w);
    vec3 lightdir;
    vec4 colDiff;
    vec3 halfVec;
    vec4 lighteffect = vec4(emission, 0.);
    vec3 col;
    float nDotL;
#ifdef FIXED_QUADS
    n = -faceforward(n, n, eye);
#endif
    
#if NLIGHTS > 0
    for (int i=0;i<NLIGHTS;i++) {
      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);
      lightdir = lightDir[i];
      if (!viewpoint[i])
        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;
      if (!finite[i]) {
        halfVec = normalize(lightdir + eye);
      } else {
        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);
        halfVec = normalize(lightdir + eye);
      }
      col = ambient[i];
      nDotL = dot(n, lightdir);
      col = col + max(nDotL, 0.) * colDiff.rgb;
      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];
      lighteffect = lighteffect + vec4(col, colDiff.a);
    }
#endif
    
#else // not IS_LIT
    vec4 colDiff = vCol;
    vec4 lighteffect = colDiff;
#endif
    
#ifdef IS_TEXT
    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);
#endif
    
#ifdef HAS_TEXTURE
#ifdef TEXTURE_rgb
    vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);
#endif
    
#ifdef TEXTURE_rgba
    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);
#endif
    
#ifdef TEXTURE_alpha
    vec4 textureColor = texture2D(uSampler, vTexcoord);
    float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;
    textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);
#endif
    
#ifdef TEXTURE_luminance
    vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);
#endif
    
#ifdef TEXTURE_luminance_alpha
    vec4 textureColor = texture2D(uSampler, vTexcoord);
    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;
    textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);
#endif
    
    fragColor = textureColor;

#elif defined(IS_TEXT)
    if (textureColor.a < 0.1)
      discard;
    else
      fragColor = textureColor;
#else
    fragColor = lighteffect;
#endif // HAS_TEXTURE
    
#ifdef HAS_FOG
    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))
    // In Exp and Exp2: use density = density/far
    // fogF will be the proportion of fog
    // Initialize it to the linear value
    float fogF;
    if (uFogMode > 0) {
      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);
      if (uFogMode > 1)
        fogF = mix(uFogParms.w, 1.0, fogF);
      fogF = fogF*uFogParms.z;
      if (uFogMode == 2)
        fogF = 1.0 - exp(-fogF);
      // Docs are wrong: use (density*c)^2, not density*c^2
      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58
      else if (uFogMode == 3)
        fogF = 1.0 - exp(-fogF*fogF);
      fogF = clamp(fogF, 0.0, 1.0);
      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);
    } else gl_FragColor = fragColor;
#else
    gl_FragColor = fragColor;
#endif // HAS_FOG
    
}
</script><!--/html_preserve-->
<script src="libs/CanvasMatrix4-1.0.1/CanvasMatrix.src.js"></script>
  <title>rglWebGL</title>
</head>
<body>
<div id="htmlwidget_container">
  <div id="rgl28345" style="width:680px;height:680px;" class="rglWebGL html-widget "></div>
</div>
<script type="application/json" data-for="rgl28345">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":425,"objects":{"431":{"id":431,"type":"spheres","material":{},"vertices":"0","colors":"1","radii":[[0.00982387457042933]],"centers":"2","ignoreExtent":false,"fastTransparency":true,"flags":32771},"433":{"id":433,"type":"text","material":{"lit":false,"margin":0,"floating":true,"edge":[0,1,1]},"vertices":"3","colors":"4","texts":[["Axis.1"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"5","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"434":{"id":434,"type":"text","material":{"lit":false,"margin":1,"floating":true,"edge":[1,1,1]},"vertices":"6","colors":"7","texts":[["Axis.2"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"8","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"435":{"id":435,"type":"text","material":{"lit":false,"margin":2,"floating":true,"edge":[1,1,1]},"vertices":"9","colors":"10","texts":[["Axis.3"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"11","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"429":{"id":429,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"428":{"id":428,"type":"background","material":{},"colors":"12","centers":"13","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"430":{"id":430,"type":"background","material":{"lit":false,"back":"lines"},"colors":"14","centers":"15","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"432":{"id":432,"type":"bboxdeco","material":{"front":"lines","back":"lines"},"vertices":"16","colors":"17","axes":{"mode":["pretty","pretty","pretty"],"step":[0.100000001490116,0.100000001490116,0.100000001490116],"nticks":[5,5,5],"marklen":[15,15,15],"expand":[1.02999997138977,1.02999997138977,1.02999997138977]},"draw_front":true,"flags":32769},"425":{"id":425,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":425,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,2.1651246547699],"modelMatrix":[[1.16579508781433,0,0,0.0808529183268547],[0,0.307277828454971,0.928029179573059,0.020978631451726],[0,-0.844238877296448,0.337775021791458,-2.27658247947693],[0,0,0,1]],"projMatrix":[[3.73205089569092,0,0,0],[0,3.73205089569092,0,0],[0,0,-3.86370348930359,-7.80502414703369],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.342020143325668,0.939692620785909,0],[0,-0.939692620785909,0.342020143325668,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1.16579508781433,0.89842027425766,0.987588047981262],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[-0.288450062274933,0.149741441011429,-0.408864378929138,0.159735307097435,-0.239992126822472,0.277269601821899],"windowRect":[86,109,342,365],"family":"sans","font":1,"cex":1,"useFreeType":false,"fontname":"TT Arial","maxClipPlanes":8,"glVersion":4.6,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[430,432,431,433,434,435,429],"subscenes":[],"flags":34067}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":680,"height":680,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":237,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":237,"type":"VEC4","normalized":true},{"bufferView":2,"componentType":5126,"count":237,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":11,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":14,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":15,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":16,"componentType":5126,"count":15,"type":"VEC3"},{"bufferView":17,"componentType":5121,"count":1,"type":"VEC4"}],"bufferViews":[{"buffer":0,"byteLength":2844,"byteOffset":0},{"buffer":0,"byteLength":948,"byteOffset":2844},{"buffer":0,"byteLength":2844,"byteOffset":3792},{"buffer":0,"byteLength":12,"byteOffset":6636},{"buffer":0,"byteLength":4,"byteOffset":6648},{"buffer":0,"byteLength":12,"byteOffset":6652},{"buffer":0,"byteLength":12,"byteOffset":6664},{"buffer":0,"byteLength":4,"byteOffset":6676},{"buffer":0,"byteLength":12,"byteOffset":6680},{"buffer":0,"byteLength":12,"byteOffset":6692},{"buffer":0,"byteLength":4,"byteOffset":6704},{"buffer":0,"byteLength":12,"byteOffset":6708},{"buffer":0,"byteLength":16,"byteOffset":6720},{"buffer":0,"byteLength":3,"byteOffset":6736},{"buffer":0,"byteLength":4,"byteOffset":6739},{"buffer":0,"byteLength":3,"byteOffset":6743},{"buffer":0,"byteLength":180,"byteOffset":6748},{"buffer":0,"byteLength":4,"byteOffset":6928}],"buffers":[{"byteLength":6932,"bytes":"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\nhLtovLW8LnMDPhsW5D3Nhwi+Ju/VvaT61j1kPss9GbvBPYnNpD1zTJO9hB6dPUfb4zvMoem9\n1qSwPXaiGj0VyW+9uoucPRVRcT3bfT89A+/dPUYwhz0jkVG8/wD/////AP9Idv////8A////\nAP9Idv///wD/////AP//AP////8A////AP///wD//wD/////AP///wD///8A////AP///wD/\n/wD///8A/////wD///8A////AP///wD///8A////AP//AP//SHb/////AP///wD/SHb//0h2\n/////wD/SHb/////AP///wD///8A//8A////AP///wD///8A/////wD///8A/0h2//9Idv//\n//8A/0h2//9Idv////8A//8A//9Idv////8A//8A/////wD///8A////AP//AP//SHb/////\nAP///wD///8A//8A////AP///wD/////AP9Idv////8A////AP9Idv////8A//8A/////wD/\nSHb/////AP//AP///wD/////AP///wD/SHb/////AP9Idv//SHb/////AP///wD///8A//8A\n//9Idv////8A/0h2//9Idv///wD/////AP///wD//wD//0h2//9Idv///wD//0h2/////wD/\n/wD/////AP///wD///8A////AP///wD///8A////AP///wD/SHb///8A/////wD/SHb/////\nAP///wD//wD/////AP///wD/SHb///8A/////wD//wD/////AP///wD///8A////AP//AP//\n/wD///8A////AP//SHb/////AP9Idv///wD/////AP//AP//SHb///8A/////wD///8A////\nAP9Idv////8A//8A////AP//SHb/////AP//AP///wD///8A/////wD//wD/////AP///wD/\n/wD/////AP///wD///8A//8A////AP////8A////AP///wD///8A////AP///wD///8A////\nAP//AP//SHb/////AP//AP////8A//8A////AP//SHb/////AP///wD///8A////AP9Idv//\nSHb/////AP//AP///wD/////AP//AP//SHb///8A/////wD///8A//8A////AP//SHb/////\nAP///wD///8A////AP9Idv///wD//0h2//9Idv////8A////AP///wD//wD//0h2/////wD/\n/wD/////AP///wD///8A////AP///wD/SHb/////AP///wD//wD/////AP//AP///wD//0h2\n/////wD///8A/0h2//9Idv///wD/////AP9Idv////8A////AP//AP////8A////AP///wD/\n//8A////AP///wD/XcDpvSzclzzaPmQ+PGdIPHmupT1ibeK9Wootvk+bCz4oQjS9MKA1vswT\naz3cuRC+lXWuPZI8HLwUDme9EaTKPYEAcT1fx1y99jPmPQRuVDx7g7O7spiTPHO9y741EdG9\n/0hFvsOdrTxqTwO9QP/YPZN6ojy4xHO9R31mvlnABz58nQW9bRGTPW+xHr6SQOk9I5TlvQj7\nhD2+hpG98mtgPUQHo77odAs+BGlXvq72kb4Rl7W9TrYVvtsfwD1Taee8fzTfPZ19AT6A+qA9\nF2HjPGTEUL608RG+2hnOPZFRcT1fuBM9NGFavuXOWj0OF9u9GddtvodrNLwy5P49qIkqvsdZ\n6buBLtW9yZ8cvpeDTz3iKLY98brkPTKizz1TTwe+aXLsPRTNFz4X7hW9EsaePQh5XL4Ncqe9\nEFIrvvXMhr1tCaA9zvUivphb17zknig+6F8FPp2/L713Pz+8av/YPUGcbz3DqDk+zLQQPrGq\nKD0k6cc9jFQLPtnf0j3L/dQ9RuLqPbUo7T2ICqs9zUjBPdz/ML6IGSO9kcVcPRkgk70kJMo9\n3Hy/PfZO97xJL7K8TkWCvhYucz3SI0+9LDZXPT7BUb7q96o79ILnPVaDyT007pU87et6PRe3\nz73ax908eWb9PdM2ET1TmS8+ELDAPeInFz3t2Na7lj/lPaP3FD1/kuw77NQbvuCOqDx2jl0+\nQQQbvosocb7issw9JiHCvUggUD1MbWK9tFeCPWJTj7x0o9490pJwvnL8k72N8Bq+Qq29PQ4n\npj03kuM9o12zPd3vnrw3PEI8cSxtvpzPJL67ehE+EP/iPS+qTD2JeHY9gjzBPVPstz3Bqp47\nt0unPfo6aD3uhym+oPbpPYZx8L1c+TE+aM/mPUwIwj37bBu96BPuPQsJIz0b0mY+muZevk66\nN74vURO9x4bPvVCoIb2pEna9vS5svmOpU7z4a7U9rLuoPTcvYb1+J6s9k1LEPSfqtj2wy3W9\nLEQovlYY2byrxoK9ld6MPc+g17zaCF291GWlPaAMi7x4MBG+lJvGPVd7j71c8JY9OkiNPTAP\n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\nzczMPQAAwH8AAMB/zcxMPgAAAAE="}]},"context":{"shiny":false,"rmarkdown":null},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n    \n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n#ifdef TEXTURE_rgb\n    vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);\n#endif\n    \n#ifdef TEXTURE_rgba\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef TEXTURE_alpha\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n    float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;\n    textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);\n#endif\n    \n#ifdef TEXTURE_luminance\n    vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);\n#endif\n    \n#ifdef TEXTURE_luminance_alpha\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n    textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);\n#endif\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script>
<script type="application/htmlwidget-sizing" data-for="rgl28345">{"viewer":{"width":680,"height":680,"padding":15,"fill":false},"browser":{"width":680,"height":680,"padding":40,"fill":false}}</script>
</body>
</html>
